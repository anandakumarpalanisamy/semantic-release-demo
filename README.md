# Semantic Release Demo

## Commands

Step 1: Clone the project and perform `npm install`.

Step 2: Install commitlint packages.

```
npm i --save-dev @commitlint/cli@latest @commitlint/config-conventional@latest
```

Step 3: Configure commitlint by creating a `.commitlintrc.json` file and copy the following config.

```
{
  "extends": [
      "@commitlint/config-conventional"
  ]
}
```

Step 4: Enable line 4 & 6 in `.husky/commit-msg` script.

At this stage, all commit messages going forward will be validated to follow [conventional commits](https://www.conventionalcommits.org/en/v1.0.0/) pattern, which is very essential for semantic versioning.

Step 5: Install following semantic-release packages.

```
npm i --save-dev @semantic-release/changelog@latest @semantic-release/commit-analyzer@latest @semantic-release/exec@latest @semantic-release/git@latest @semantic-release/github@latest @semantic-release/release-notes-generator@latest
```

Step 6: Configure semanatic release plugin by creating a `.releaserc.json` file and add the following config

```
{
  "branches": [
    "main"
  ],
  "plugins": [
    [
      "@semantic-release/commit-analyzer",
      {
        "preset": "conventionalcommits"
      }
    ],
    "@semantic-release/release-notes-generator",
    "@semantic-release/changelog",
    [
      "@semantic-release/git",
      {
        "assets": [
          "package.json",
          "CHANGELOG.md"
        ],
        "message": "chore(release): ${nextRelease.version} [skip ci]\n\n${nextRelease.notes}"
      }
    ],
    "@semantic-release/github",
    [
      "@semantic-release/exec",
      {
        "publishCmd": "echo nextVersion=${nextRelease.version} >> $GITHUB_OUTPUT"
      }
    ]
  ]
}
```

Step 6: Add a GitHub Actions workflow for releasing from `main` branch.

```
name: Create Release

on:
  push:
    branches:
      - "main"

env:
  NODE_VERSION: "20.x"

jobs:
  create-release:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          registry-url: "https://npm.pkg.github.com"
      - name: Install Dependencies
        run: npm ci
      - name: Semantic Release
        id: semantic-release
        run: npx semantic-release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    outputs:
      version: ${{ steps.semantic-release.outputs.nextVersion }}
```

Step 7: At this stage, when you start adding features/fixes/breaking change to your project and merge to main, you should see automated releases created in GitHub.

### Problem

But problem though is usually this won't be possible in an enteprise level setup where using merging to `default` (i.e., `main`) branch is protected with need for Pull Requests. automated checks and code review approvals.

You can get around this by creating an admin user and assign relevant permissions to a PAT token and add the admin user under branch protection bypass rules.

This requires more secrets management and not encouraged.

## GitHub App for release

To avoid the hassle of managing either PAT Tokens or Tokens generated by Admin (long-lived) and more secret management, please use Github App
approach.

- Go to Developer settings -> GitHub Apps and create a new App.
- Fill a name for the app, add a description and add your repo url as homepage url for the app :).
- Uncheck `Webhook` settings.
- Select following Permissions.
  - Administration - Read And Write
  - Contents - Read And Write
  - Issues - Read And Write
  - Pull Requests - Read And Write
  - Metadata - Read Only (selected by default)
- Save.
- Add a Private Key from the App page, by scrolling to the section `Private Keys`.
- You get a Private Key downloaded to the machine.
- Copy the `APP ID` from the top of the page.
- Now, save these to as secrets in Actions -> Secrets in `RELEASE_APP_PRIVATE_KEY` and `RELEASE_APP_ID`.

### Amend the GitHub Actions workflow as follows;

```
name: Create Release

on:
  push:
    branches:
      - "main"

env:
  NODE_VERSION: "20.x"

jobs:
  create-release:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - name: 'Generate token'
        id: generate_token
        uses: tibdex/github-app-token@v2
        with:
          app_id: ${{ secrets.GH_RELEASE_APP_ID }}
          private_key: ${{ secrets.GH_RELEASE_APP_PRIVATE_KEY }}
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ needs.generate-token.outputs.token }}
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          registry-url: "https://npm.pkg.github.com"
      - name: Install Dependencies
        run: npm ci
      - name: Semantic Release
        id: semantic-release
        run: npx semantic-release
        env:
          GITHUB_TOKEN: ${{ needs.generate-token.outputs.token }}
    outputs:
      version: ${{ steps.semantic-release.outputs.nextVersion }}
```

### Finally, amend the Branch Protection Rules

Now, you can amend the branch protection rules to bypass PullRequests and force push to main branch for actor: <select your github app>

## Appendix: If release is based on a different release branch (for ex: stable) other than main, to rebase main based on release branch.

Note the `.releaserc.json` should have the branches set to `stable` for this to work.

```
rebase-main:
  runs-on: ubuntu-latest
  needs: create-release
  steps:
    - name: Checkout all branches
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    - name: Checkout main branch
      run: git checkout main
      shell: bash
    - name: Rebase main from stable
      run: |
        git fetch origin
        git rebase origin/stable
      shell: bash
    - name: Push changes
      run: |
        git push origin main
      shell: bash
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```
